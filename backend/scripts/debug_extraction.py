#!/usr/bin/env python3
"""Debug script to understand why extraction patterns aren't working."""

import re
from bs4 import BeautifulSoup


MOCK_10Q = """
<html>
<body>
<div>
PART I — FINANCIAL INFORMATION

ITEM 1. CONDENSED CONSOLIDATED FINANCIAL STATEMENTS

APPLE INC.
CONDENSED CONSOLIDATED STATEMENTS OF OPERATIONS (Unaudited)
(In millions)

                                          Three Months Ended
                                          July 1,   June 25,
                                           2023      2022

Net sales:
  Products                               $60,584   $63,355
  Services                                21,213    19,604
    Total net sales                       81,797    82,959

Cost of sales:
  Products                                38,877    41,179
  Services                                 6,060     5,739
    Total cost of sales                   44,937    46,918

Gross margin                              36,860    36,041
Net income                               $20,328   $19,598

Earnings per share:
  Basic                                    $1.27     $1.20
  Diluted                                  $1.26     $1.20
</div>

<div>
ITEM 2. MANAGEMENT'S DISCUSSION AND ANALYSIS OF FINANCIAL CONDITION AND RESULTS OF OPERATIONS

Total net sales decreased 1% or $1.2 billion during the third quarter.
The Company's total gross margin was 45.0%.
Cash generated by operating activities was $58.9 billion.
</div>

<div>
ITEM 1A. RISK FACTORS

The Company's business can be affected by global economic conditions.
The technology industry is highly competitive.
</div>
</body>
</html>
"""

# First, let's see what BeautifulSoup produces
soup = BeautifulSoup(MOCK_10Q, 'html.parser')
clean_text = soup.get_text(separator='\n', strip=False)

print("=" * 70)
print("Cleaned text from BeautifulSoup:")
print("=" * 70)
print(clean_text[:2000])
print()

# Now test the patterns
print("=" * 70)
print("Testing extraction patterns:")
print("=" * 70)

# Pattern 1: Financial statements
financial_patterns = [
    r"ITEM\s*1\.?\s*[-–—]?\s*(?:CONDENSED\s+)?(?:CONSOLIDATED\s+)?FINANCIAL\s+STATEMENTS[^\n]*\n(.*?)(?=ITEM\s*2|NOTES\s+TO|MANAGEMENT|$)",
]

for i, pattern in enumerate(financial_patterns):
    print(f"\nPattern {i+1}: {pattern[:60]}...")
    match = re.search(pattern, clean_text, re.IGNORECASE | re.DOTALL | re.MULTILINE)
    if match:
        content = match.group(1)
        print(f"  MATCH! Content length: {len(content)}")
        print(f"  Content preview: {content[:200]}...")
    else:
        print("  NO MATCH")

# The problem might be that the lookahead (?=ITEM\s*2|...) is matching immediately
# because there's no content between ITEM 1 header and the lookahead in the regex context

# Let's try a different approach - match everything up to the next ITEM
print("\n" + "=" * 70)
print("Testing simpler pattern:")
print("=" * 70)

# Simpler pattern that looks for ITEM 1 followed by content until ITEM 2
simple_pattern = r"ITEM\s*1\.?\s*[^\n]*FINANCIAL\s+STATEMENTS[^\n]*\n([\s\S]*?)(?=ITEM\s*2\.?\s*MANAGEMENT)"
match = re.search(simple_pattern, clean_text, re.IGNORECASE)
if match:
    content = match.group(1)
    print(f"Simple pattern MATCH! Content length: {len(content)}")
    print(f"Content:\n{content[:500]}")
else:
    print("Simple pattern NO MATCH")

# Even simpler - just get text between "ITEM 1" and "ITEM 2"
print("\n" + "=" * 70)
print("Testing very simple pattern:")
print("=" * 70)

very_simple = r"(ITEM\s*1\.?.*?)(ITEM\s*2\.?)"
match = re.search(very_simple, clean_text, re.IGNORECASE | re.DOTALL)
if match:
    content = match.group(1)
    print(f"Very simple pattern MATCH! Content length: {len(content)}")
    print(f"Content:\n{content[:500]}")
else:
    print("Very simple pattern NO MATCH")
